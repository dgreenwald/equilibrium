from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING, List, Mapping, Optional, Sequence, Union

import numpy as np

if TYPE_CHECKING:
    from ..solvers.results import (
        DeterministicResult,
        SequenceResult,
        SeriesTransform,
    )


@dataclass
class PreparedPaths:
    """
    Container for prepared deterministic paths ready for plotting or analysis.

    This dataclass holds harmonized, transformed simulation paths along with
    metadata needed for plotting or numerical analysis.

    Attributes
    ----------
    path_vals : np.ndarray
        Array of shape (n_results, n_periods, n_vars) containing harmonized
        variable values across all results.
    var_names : List[str]
        Variable names aligned with the third axis of path_vals.
    result_names : List[str]
        Result names aligned with the first axis of path_vals.
    processed_results : List[DeterministicResult]
        List of transformed DeterministicResult objects (after applying
        series_transforms).
    n_periods : int
        Common time dimension (minimum across all results).
    """

    path_vals: np.ndarray
    var_names: List[str]
    result_names: List[str]
    processed_results: List["DeterministicResult"]
    n_periods: int


def overlay_to_result(
    overlay_data: Union[np.ndarray, Mapping[str, np.ndarray]],
    overlay_var_names: Optional[Sequence[str]] = None,
    overlay_name: str = "Data",
    reference_result: Optional["DeterministicResult"] = None,
    fill_missing: bool = True,
) -> "DeterministicResult":
    """
    Convert external overlay data to DeterministicResult format for plotting.

    This helper function enables overlaying empirical data, alternative model outputs,
    or other external time series on plots generated by plot_deterministic_results().
    The returned DeterministicResult can be appended to a results list for comparison.

    Parameters
    ----------
    overlay_data : np.ndarray or Mapping[str, np.ndarray]
        External data to overlay. Either a 2D array of shape (n_periods, n_vars)
        or a dictionary mapping variable names to 1D arrays of length n_periods.
    overlay_var_names : Sequence[str], optional
        Variable names corresponding to columns of overlay_data when overlay_data
        is an array. Required if overlay_data is an array; ignored if it's a dict.
    overlay_name : str, default "Data"
        Label for the overlay series (used in legends and saved result metadata).
    reference_result : DeterministicResult, optional
        Reference result used to align variable names and fill missing columns.
        If provided and fill_missing=True, the overlay will be padded with NaN
        columns for variables in the reference that are not in the overlay.
    fill_missing : bool, default True
        Whether to add NaN columns for variables present in reference_result but
        not in overlay_data. Only used when reference_result is provided.

    Returns
    -------
    DeterministicResult
        Result container with:
        - UX: overlay data (possibly padded with NaN for missing variables)
        - Z: zeros placeholder of shape (n_periods, 1)
        - var_names: variable names from overlay
        - model_label: overlay_name
        - Minimal metadata (converged=True, final_residual=0.0)

    Raises
    ------
    ValueError
        If overlay_data is an array but overlay_var_names is not provided, or if
        arrays in a dict have inconsistent lengths.
    TypeError
        If overlay_data is neither an array nor a dict.

    Examples
    --------
    >>> # Create overlay from dict
    >>> empirical = {'consumption': np.array([1.0, 1.1, 1.2]),
    ...              'output': np.array([2.0, 2.1, 2.2])}
    >>> overlay_result = overlay_to_result(empirical, overlay_name="Empirical")
    >>> # Create overlay from array
    >>> data_array = np.random.randn(50, 3)
    >>> overlay_result = overlay_to_result(
    ...     data_array,
    ...     overlay_var_names=['c', 'y', 'k'],
    ...     overlay_name="Historical",
    ... )
    >>> # Align with reference result
    >>> overlay_result = overlay_to_result(
    ...     empirical,
    ...     overlay_name="Data",
    ...     reference_result=simulation_result,
    ...     fill_missing=True,
    ... )
    """
    from ..solvers.results import DeterministicResult

    # Convert overlay_data to dict format
    if isinstance(overlay_data, dict):
        # Convert all values to numeric arrays, handling pandas object dtypes
        overlay_dict = {}
        for key, value in overlay_data.items():
            try:
                overlay_dict[key] = np.asarray(value, dtype=np.float64)
            except (ValueError, TypeError) as e:
                raise ValueError(
                    f"Cannot convert overlay variable '{key}' to numeric. "
                    f"Ensure all overlay data is numeric. Original error: {e}"
                )

        # Validate consistent lengths
        if overlay_dict:
            lengths = {k: len(v) for k, v in overlay_dict.items()}
            unique_lengths = set(lengths.values())
            if len(unique_lengths) > 1:
                raise ValueError(
                    f"All arrays in overlay_data dict must have the same length. "
                    f"Got lengths: {lengths}"
                )
        var_names = list(overlay_dict.keys())
    elif isinstance(overlay_data, np.ndarray):
        if overlay_var_names is None:
            raise ValueError(
                "overlay_var_names must be provided when overlay_data is an array"
            )
        try:
            overlay_arr = np.asarray(overlay_data, dtype=np.float64)
        except (ValueError, TypeError) as e:
            raise ValueError(
                f"Cannot convert overlay_data array to numeric. "
                f"Ensure all overlay data is numeric. Original error: {e}"
            )
        if overlay_arr.ndim == 1:
            overlay_arr = overlay_arr[:, None]
        elif overlay_arr.ndim != 2:
            raise ValueError(
                f"overlay_data array must be 1D or 2D, got {overlay_arr.ndim}D"
            )
        n_periods, n_vars = overlay_arr.shape
        if len(overlay_var_names) != n_vars:
            raise ValueError(
                f"overlay_var_names length ({len(overlay_var_names)}) must match "
                f"number of columns in overlay_data ({n_vars})"
            )
        var_names = list(overlay_var_names)
        overlay_dict = {name: overlay_arr[:, i] for i, name in enumerate(var_names)}
    else:
        raise TypeError(
            f"overlay_data must be a numpy array or dict, got {type(overlay_data)}"
        )

    # Align with reference result if provided
    if reference_result is not None and fill_missing:
        # Get all variable names from reference (UX and Y)
        ref_var_names = list(reference_result.var_names)
        if reference_result.Y is not None:
            ref_var_names.extend(reference_result.y_names)

        # Build aligned array with reference variable order
        n_periods = len(next(iter(overlay_dict.values())))
        aligned_var_names = []
        aligned_arrays = []

        for ref_var in ref_var_names:
            aligned_var_names.append(ref_var)
            if ref_var in overlay_dict:
                # Force numeric conversion to handle pandas object dtypes
                try:
                    aligned_arrays.append(
                        np.asarray(overlay_dict[ref_var], dtype=np.float64)
                    )
                except (ValueError, TypeError) as e:
                    raise ValueError(
                        f"Cannot convert overlay variable '{ref_var}' to numeric. "
                        f"Ensure all overlay data is numeric. Original error: {e}"
                    )
            else:
                # Fill missing with NaN
                aligned_arrays.append(np.full(n_periods, np.nan))

        # Add overlay variables not in reference (append at end)
        for overlay_var in var_names:
            if overlay_var not in ref_var_names:
                aligned_var_names.append(overlay_var)
                try:
                    aligned_arrays.append(
                        np.asarray(overlay_dict[overlay_var], dtype=np.float64)
                    )
                except (ValueError, TypeError) as e:
                    raise ValueError(
                        f"Cannot convert overlay variable '{overlay_var}' to numeric. "
                        f"Ensure all overlay data is numeric. Original error: {e}"
                    )

        UX = np.column_stack(aligned_arrays)
        var_names = aligned_var_names
    else:
        # No alignment, just stack in original order
        arrays = []
        for name in var_names:
            try:
                arrays.append(np.asarray(overlay_dict[name], dtype=np.float64))
            except (ValueError, TypeError) as e:
                raise ValueError(
                    f"Cannot convert overlay variable '{name}' to numeric. "
                    f"Ensure all overlay data is numeric. Original error: {e}"
                )
        UX = np.column_stack(arrays) if len(arrays) > 1 else arrays[0][:, None]

    # Ensure UX is 2D
    if UX.ndim == 1:
        UX = UX[:, None]

    n_periods = UX.shape[0]

    # Create placeholder Z (zeros)
    Z = np.zeros((n_periods, 1))

    # Create DeterministicResult
    return DeterministicResult(
        UX=UX,
        Z=Z,
        var_names=var_names,
        exog_names=["_placeholder"],
        y_names=[],
        Y=None,
        model_label=overlay_name,
        converged=True,
        final_residual=0.0,
    )


def prepare_deterministic_paths(
    results: Optional[Sequence[Union["DeterministicResult", "SequenceResult"]]] = None,
    include_list: Optional[Sequence[str]] = None,
    *,
    T_max: Optional[int] = None,
    series_transforms: Optional[
        Mapping[str, Union["SeriesTransform", Mapping[str, any]]]
    ] = None,
    result_labels: Optional[Sequence[tuple[str, Optional[str]]]] = None,
    result_kind: str = "sequence",
    save_dir: Optional[Union[str, Path]] = None,
    result_names: Optional[Sequence[str]] = None,
    overlay_data: Optional[Union[np.ndarray, Mapping[str, np.ndarray]]] = None,
    overlay_var_names: Optional[Sequence[str]] = None,
    overlay_name: str = "Data",
) -> PreparedPaths:
    """
    Prepare deterministic paths for plotting or numerical analysis.

    This function handles loading, transforming, harmonizing, and aligning
    deterministic simulation results into a unified data structure. It performs
    the same preprocessing used by plot_deterministic_results, but returns
    the prepared data for custom analysis instead of plotting.

    Parameters
    ----------
    results : Sequence[DeterministicResult | SequenceResult], optional
        List of result objects to prepare. SequenceResult objects will be spliced
        into DeterministicResult objects using the splice method.
    include_list : Sequence[str], optional
        List of variable names to include in the output. Variables not present
        in a result will be filled with NaN. If None, defaults to all variables
        present in any result.
    T_max : int, optional
        Maximum number of time periods to include when splicing SequenceResult
        objects. If None, SequenceResults use their default splice length, and
        the final output uses the minimum path length across all results.
    series_transforms : dict[str, SeriesTransform or dict], optional
        Per-series transform specifications keyed by series name. Applies
        across UX, Z, and Y names for each result (e.g., log_to_level,
        deviations from steady state).
    result_labels : Sequence[tuple[str, Optional[str]]], optional
        List of (model_label, experiment_label) pairs to load and prepare. Loaded
        results are appended after any explicit ``results``.
    result_kind : str, default "sequence"
        Type of labeled results to load: "sequence" or "deterministic".
    save_dir : str or Path, optional
        Base directory used to load labeled results. Defaults to settings.
    result_names : Sequence[str], optional
        Names for each result (used in legends/identification). If None, defaults
        to explicit "Result {i}" entries followed by label-derived names for any
        ``result_labels``.
    overlay_data : np.ndarray or dict[str, np.ndarray], optional
        External data to overlay (e.g., empirical data for comparison). Either
        a 2D array of shape (n_periods, n_vars) or a dict mapping variable names
        to 1D arrays. When provided, this data is converted to a DeterministicResult
        and appended to the results list.
    overlay_var_names : Sequence[str], optional
        Variable names for overlay_data when it's an array. Required if
        overlay_data is an array; ignored if it's a dict.
    overlay_name : str, default "Data"
        Name for the overlay series (used in result_names).

    Returns
    -------
    PreparedPaths
        Container with:
        - path_vals: np.ndarray of shape (n_results, n_periods, n_vars)
        - var_names: List[str] - variable names (aligned with axis 2 of path_vals)
        - result_names: List[str] - result names (aligned with axis 0 of path_vals)
        - processed_results: List[DeterministicResult] - transformed results
        - n_periods: int - common time dimension (minimum across all results)

    Raises
    ------
    ValueError
        If results is empty, if overlay_data is an array but overlay_var_names
        is not provided, if arrays in overlay_data dict have inconsistent lengths,
        or if result_names length doesn't match number of results.
    TypeError
        If a result is neither DeterministicResult nor SequenceResult.

    Examples
    --------
    >>> from equilibrium.plot import prepare_deterministic_paths
    >>> # Prepare paths from explicit results
    >>> prep = prepare_deterministic_paths(
    ...     [det_result1, det_result2],
    ...     include_list=["consumption", "output"],
    ...     result_names=["Baseline", "Alternative"],
    ... )
    >>> # Access specific values
    >>> var_idx = prep.var_names.index("consumption")
    >>> consumption_baseline = prep.path_vals[0, :, var_idx]
    >>> # Prepare with overlay data for analysis
    >>> empirical = {'consumption': np.array([...]), 'output': np.array([...])}
    >>> prep = prepare_deterministic_paths(
    ...     result_labels=[('baseline', 'pti_lib')],
    ...     include_list=['log_price_rent', 'log_lti_new_agg'],
    ...     series_transforms=K.series_transforms,
    ...     overlay_data=empirical,
    ...     overlay_name="Empirical",
    ... )
    >>> # Model value at specific period
    >>> model_idx = 0  # First non-overlay result
    >>> var_idx = prep.var_names.index('log_price_rent')
    >>> model_value = prep.path_vals[model_idx, 37, var_idx]
    >>> # Overlay data peak
    >>> overlay_idx = len(prep.result_names) - 1  # Last result is overlay
    >>> overlay_series = prep.path_vals[overlay_idx, :, var_idx]
    >>> data_peak = np.nanmax(overlay_series)
    """
    # Import here to avoid circular imports
    from ..settings import get_settings
    from ..solvers.results import DeterministicResult, SequenceResult
    from ..utils.io import load_deterministic_result, load_sequence_result

    results_list: List[DeterministicResult] = []
    auto_names: List[str] = []

    # Process explicit results
    if results is not None:
        for result in results:
            if isinstance(result, SequenceResult):
                results_list.append(result.splice(T_max=T_max))
            elif isinstance(result, DeterministicResult):
                results_list.append(result)
            else:
                raise TypeError(
                    "results must contain DeterministicResult or SequenceResult, "
                    f"got {type(result).__name__}."
                )
        auto_names.extend([f"Result {i}" for i in range(len(results_list))])

    # Load labeled results
    if result_labels:
        for model_label, experiment_label in result_labels:
            if result_kind == "sequence":
                loaded = load_sequence_result(
                    model_label,
                    experiment_label,
                    save_dir=save_dir,
                    splice=True,
                    T_max=T_max,
                )
            elif result_kind == "deterministic":
                loaded = load_deterministic_result(
                    model_label, experiment_label, save_dir=save_dir
                )
            else:
                raise ValueError(
                    "result_kind must be 'sequence' or 'deterministic', "
                    f"got '{result_kind}'."
                )
            results_list.append(loaded)
            label_str = (
                f"{model_label}_{experiment_label}" if experiment_label else model_label
            )
            auto_names.append(label_str)

    # Process overlay data if provided
    if overlay_data is not None:
        # Get reference result for alignment (first result if available)
        reference_result = results_list[0] if results_list else None

        # Convert overlay to DeterministicResult
        overlay_result = overlay_to_result(
            overlay_data=overlay_data,
            overlay_var_names=overlay_var_names,
            overlay_name=overlay_name,
            reference_result=reference_result,
            fill_missing=True,
        )

        # Append overlay result to results list
        results_list.append(overlay_result)
        auto_names.append(overlay_name)

    if not results_list:
        raise ValueError("results must be a non-empty sequence")

    # Apply series transforms if provided
    processed_results: List[DeterministicResult] = []
    if series_transforms:
        for result in results_list:
            processed_results.append(result.transform(series_transforms=series_transforms))
    else:
        processed_results = results_list

    # Set default result names
    if result_names is None:
        result_names = auto_names
    else:
        # Validate result_names length
        # If overlay was added, result_names should match original results (not including overlay)
        expected_length = len(processed_results) - (
            1 if overlay_data is not None else 0
        )
        if len(result_names) != expected_length:
            raise ValueError(
                f"result_names length ({len(result_names)}) must match "
                f"number of non-overlay results ({expected_length})"
            )
        # Append overlay name if overlay was added
        if overlay_data is not None:
            result_names = list(result_names) + [overlay_name]

    # Determine the union of all variable names that exist in any result
    # Include both UX variables (var_names) and intermediate variables (y_names)
    all_var_names: List[str] = []
    for result in processed_results:
        for name in result.var_names:
            if name not in all_var_names:
                all_var_names.append(name)
        for name in result.y_names:
            if name not in all_var_names:
                all_var_names.append(name)

    # Set default include_list to all variables if not provided
    if include_list is None:
        include_list = all_var_names

    # Filter to only variables in include_list (preserving include_list order)
    var_names = [v for v in include_list if v in all_var_names]

    if not var_names:
        raise ValueError(
            f"None of the variables in include_list {list(include_list)} "
            f"are present in any result. Available variables: {all_var_names}"
        )

    # Determine the common time dimension (min across all results)
    n_periods = min(r.UX.shape[0] for r in processed_results)

    # Build path_vals array: shape (n_results, n_periods, n_vars)
    n_results = len(processed_results)
    n_vars = len(var_names)
    path_vals = np.full((n_results, n_periods, n_vars), np.nan)

    for i, result in enumerate(processed_results):
        for j, var_name in enumerate(var_names):
            if var_name in result.var_names:
                var_idx = result.var_names.index(var_name)
                # Take up to n_periods from this result
                path_vals[i, :, j] = result.UX[:n_periods, var_idx]
            elif var_name in result.y_names and result.Y is not None:
                # Variable is in intermediate variables (Y)
                var_idx = result.y_names.index(var_name)
                path_vals[i, :, j] = result.Y[:n_periods, var_idx]

    return PreparedPaths(
        path_vals=path_vals,
        var_names=var_names,
        result_names=list(result_names),
        processed_results=processed_results,
        n_periods=n_periods,
    )
