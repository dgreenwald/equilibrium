{# -----------------------------------------------------------------
   functions.py.jinja
   Render a list of Python functions given:
     • funcs: list[dict] where each dict has
         name       : str           # the name of the function
         args       : list[str]     # list of arguments
         body       : list[str]     # raw code lines
         returns    : list[str]     # list of variables to return
     • core_vars: list[str], list of variables used as initial inputs
     • derived_vars: list[str], list of variables created as part of the computation
     • return_mutate: bool, set to True to return a new State object with the return fields set
     • return_array : bool, set to True to return an array
     • jit: bool, if True, wrap functions in @jax.jit
   ----------------------------------------------------------------- #}

{% extends "base.py.jinja" %}

{% block body %}

from typing import NamedTuple

class State(NamedTuple):
{% for var in core_vars %}
    {{ var }}: np.ndarray
{% endfor %}
{% for var in derived_vars %}
    {{ var }}: np.ndarray
{% endfor %}

    def __getitem__(self, key):
        return getattr(self, key)

# Define constants for pytree registration
_CORE_VARS = {{ core_vars }}
_DERIVED_VARS = {{ derived_vars }}
_NUM_CORE = {{ core_vars|length }}
_NUM_DERIVED = {{ derived_vars|length }}

def _flatten_state(state):
    """Flatten State into pytree children and auxiliary data."""
    children = tuple(getattr(state, var) for var in _CORE_VARS)
    aux_data = {
        'num_core': _NUM_CORE,
        'num_derived': _NUM_DERIVED,
    }
    return (children, aux_data)

def _unflatten_state(aux_data, children):
    """Reconstruct State from pytree children and auxiliary data."""
    template = children[0]
    nans = tuple(np.full_like(template, np.nan) for _ in range(aux_data['num_derived']))
    return State(*children, *nans)

# Register State as JAX pytree
jax.tree_util.register_pytree_node(
    State,
    _flatten_state,
    _unflatten_state
)

def _upd(st: State, **kw):
    """Pure functional update: returns a new State with fields replaced."""
    return st._replace(**kw)

def array_to_state(x):
    """Initialize State from array x"""
    {#dtype = x.dtype#}
    nan = np.nan * x[0]
    return State(
{% for var in core_vars %}
        {{ var }}=x[{{ loop.index0 }}],
{% endfor %}
{% for var in derived_vars %}
        {{ var }}=nan,
{% endfor %}
    )

def state_to_array(st):
    """Convert State to flat array containing only core variables."""
    return np.array([
{% for var in core_vars %}
        st.{{ var }},
{% endfor %}
    ])

{% for fn in funcs %}
{% if jit %}
@jax.jit
{% endif %}
def {{ fn.name }}({{ fn.args|join(", ") }}):
    {#print('Tracing {{ fn.name }}', flush=True)#}
{% for line in fn.body %}
    {{ line }}
{% endfor %}
    {#{% if fn.return_array is not none %}#}
    {% if fn.return_mutate %}
    return _upd(st,
        {% for return in fn.returns %}
        {{ return }}={{ return }},
        {% endfor %}
    )
    {% elif fn.return_array %}
    return np.array((
        {% for return in fn.returns %}
        {{ return }},
        {% endfor %}
        ))
    {% else %}
    return {{ fn.returns|join(',') }}
    {% endif %}

{% endfor %}
{% endblock %}
